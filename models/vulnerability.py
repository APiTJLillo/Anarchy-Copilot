"""Vulnerability-related models."""
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, JSON, Enum, Text, Table, Float, Boolean
from sqlalchemy.orm import relationship
from datetime import datetime
import enum

from database import Base
from .base import Project

# Association tables for many-to-many relationships
vulnerability_tags = Table(
    'vulnerability_tags',
    Base.metadata,
    Column('vulnerability_id', Integer, ForeignKey('vulnerabilities.id')),
    Column('tag_id', Integer, ForeignKey('tags.id'))
)

report_vulnerabilities = Table(
    'report_vulnerabilities',
    Base.metadata,
    Column('report_id', Integer, ForeignKey('reports.id')),
    Column('vulnerability_id', Integer, ForeignKey('vulnerabilities.id'))
)

class SeverityLevel(enum.Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

class VulnerabilityStatus(enum.Enum):
    OPEN = "open"
    IN_PROGRESS = "in_progress"
    VERIFIED = "verified"
    FIXED = "fixed"
    WONT_FIX = "wont_fix"
    FALSE_POSITIVE = "false_positive"

class Vulnerability(Base):
    __tablename__ = "vulnerabilities"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True)
    description = Column(Text)
    severity = Column(Enum(SeverityLevel))
    status = Column(Enum(VulnerabilityStatus), default=VulnerabilityStatus.OPEN)
    cvss_score = Column(Float, nullable=True)
    proof_of_concept = Column(Text)
    steps_to_reproduce = Column(Text)
    technical_details = Column(Text)
    recommendation = Column(Text)
    discovered_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Foreign keys
    project_id = Column(Integer, ForeignKey("projects.id"))
    assigned_user_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    recon_result_id = Column(Integer, ForeignKey("recon_results.id"), nullable=True)
    
    # Relationships
    project = relationship("Project", back_populates="vulnerabilities")
    assigned_user = relationship("User", back_populates="assigned_vulnerabilities")
    recon_result = relationship("ReconResult", back_populates="vulnerabilities")
    tags = relationship("Tag", secondary=vulnerability_tags, back_populates="vulnerabilities")
    comments = relationship("VulnerabilityComment", back_populates="vulnerability")
    reports = relationship("Report", secondary=report_vulnerabilities, back_populates="vulnerabilities")

class VulnerabilityComment(Base):
    __tablename__ = "vulnerability_comments"

    id = Column(Integer, primary_key=True, index=True)
    content = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Foreign keys
    vulnerability_id = Column(Integer, ForeignKey("vulnerabilities.id"))
    user_id = Column(Integer, ForeignKey("users.id"))
    
    # Relationships
    vulnerability = relationship("Vulnerability", back_populates="comments")
    user = relationship("User")

class Tag(Base):
    __tablename__ = "tags"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, unique=True, index=True)
    description = Column(Text, nullable=True)
    
    # Relationships
    vulnerabilities = relationship("Vulnerability", secondary=vulnerability_tags, back_populates="tags")

class VulnerabilityScan(Base):
    __tablename__ = "vulnerability_scans"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, index=True)  # Name of the scan
    scan_type = Column(String)  # Type of scan (e.g. "web", "network", "code")
    target = Column(String)  # What was scanned (URL, IP, file path, etc)
    scanner = Column(String)  # Tool used (e.g. "ZAP", "Nessus", "Snyk")
    status = Column(String)  # Status of the scan (running, completed, failed)
    is_full_scan = Column(Boolean, default=True)  # Full scan vs targeted/partial scan
    start_time = Column(DateTime, default=datetime.utcnow)
    end_time = Column(DateTime, nullable=True)
    config = Column(JSON, nullable=True)  # Scanner configuration used
    error_message = Column(String, nullable=True)  # Error message if scan failed
    
    # Foreign keys
    project_id = Column(Integer, ForeignKey("projects.id"))

    # Relationships
    project = relationship("Project")
    results = relationship("VulnerabilityResult", back_populates="scan")

    def to_dict(self):
        return {
            "id": self.id,
            "name": self.name,
            "scan_type": self.scan_type,
            "target": self.target,
            "scanner": self.scanner,
            "status": self.status,
            "is_full_scan": self.is_full_scan,
            "start_time": self.start_time.isoformat() if self.start_time else None,
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "config": self.config,
            "error_message": self.error_message,
            "project_id": self.project_id
        }

class VulnerabilityResult(Base):
    __tablename__ = "vulnerability_results"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True)  # Brief description of finding
    description = Column(Text)  # Detailed explanation
    severity = Column(Enum(SeverityLevel))  # Severity rating
    location = Column(String)  # Where the issue was found (URL, file, etc)
    evidence = Column(Text)  # Raw evidence of the finding
    confidence = Column(String)  # How confident the scanner is (high, medium, low)
    cwe_id = Column(String, nullable=True)  # CWE identifier if applicable
    detected_at = Column(DateTime, default=datetime.utcnow)
    scan_data = Column(JSON, nullable=True)  # Raw scanner output
    false_positive = Column(Boolean, default=False)  # Whether this was marked as a false positive
    ignored = Column(Boolean, default=False)  # Whether to ignore this result
    notes = Column(Text, nullable=True)  # Additional notes/context
    
    # Foreign keys
    scan_id = Column(Integer, ForeignKey("vulnerability_scans.id"))
    vulnerability_id = Column(Integer, ForeignKey("vulnerabilities.id"), nullable=True)
    project_id = Column(Integer, ForeignKey("projects.id"))

    # Relationships
    scan = relationship("VulnerabilityScan", back_populates="results")
    vulnerability = relationship("Vulnerability", uselist=False)
    project = relationship("Project")

    def to_dict(self):
        return {
            "id": self.id,
            "title": self.title,
            "description": self.description,
            "severity": self.severity.value if self.severity else None,
            "location": self.location,
            "evidence": self.evidence,
            "confidence": self.confidence,
            "cwe_id": self.cwe_id,
            "detected_at": self.detected_at.isoformat() if self.detected_at else None,
            "scan_data": self.scan_data,
            "false_positive": self.false_positive,
            "ignored": self.ignored,
            "notes": self.notes,
            "scan_id": self.scan_id,
            "vulnerability_id": self.vulnerability_id,
            "project_id": self.project_id
        }

class Report(Base):
    __tablename__ = "reports"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True)
    executive_summary = Column(Text)
    methodology = Column(Text)
    findings_summary = Column(Text)
    recommendations = Column(Text)
    conclusion = Column(Text)
    report_type = Column(String)  # e.g., "Technical", "Executive", "Full"
    status = Column(String)  # e.g., "Draft", "In Review", "Final"
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Foreign keys
    project_id = Column(Integer, ForeignKey("projects.id"))
    author_id = Column(Integer, ForeignKey("users.id"))
    
    # Relationships
    project = relationship("Project", back_populates="reports")
    author = relationship("User", back_populates="authored_reports")
    vulnerabilities = relationship("Vulnerability", secondary=report_vulnerabilities, back_populates="reports")
